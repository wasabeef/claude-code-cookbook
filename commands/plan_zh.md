## 计划制定

启动实施前的计划制定模式，制定详细的实施策略。通过在代码实现前制定结构化计划，支持高效开发。

### 使用方法

```bash
# 向Claude请求Plan Mode
「制定[实施内容]的实施计划」
```

### 基本示例

```bash
# 新功能实施计划
「制定用户认证功能的实施计划」

# 系统设计计划
「制定微服务拆分的实施计划」

# 重构计划
「制定遗留代码的重构计划」
```

### 与Claude协作

```bash
# 复杂功能实现
「制定聊天功能的实施计划，包括WebSocket、实时通知和历史管理」

# 数据库设计
「制定电商网站的数据库设计计划，包括商品、订单和用户管理」

# API设计
「制定GraphQL API的实施计划，包括认证、缓存和速率限制」

# 基础设施设计
「制定Docker化的实施计划，包括开发环境、生产环境和CI/CD」
```

### Plan Mode的特点

**自动启动**

- 检测到实施任务时自动启动Plan Mode
- 可通过「制定实施计划」等关键词明确启动

**结构化规范文档**

- 需求定义（用户故事、验收标准）
- 设计文档（架构、数据设计、UI设计）
- 实施计划（任务分解、进度跟踪、质量保证）
- 风险分析和对策

**审批流程**

- 使用`exit_plan_mode`工具提交计划
- **重要**：无论工具返回值如何，务必等待用户明确审批
- 禁止未经审批开始实施
- 可修改和调整计划
- 仅在审批后通过TodoWrite开始任务管理

### 详细示例

```bash
# 复杂系统实施
「制定在线支付系统的实施计划，包括Stripe集成、安全和错误处理」

# 前端实施
「制定React仪表盘的实施计划，包括状态管理、组件设计和测试」

# 后端实施
「制定RESTful API的实施计划，包括认证、验证和日志记录」

# DevOps实施
「制定CI/CD流水线的实施计划，包括测试自动化、部署和监控」
```

### 3阶段工作流程

#### 阶段1: Requirements（需求定义）

- **用户故事**：明确功能的目的和价值
- **验收标准**：定义完成条件和质量标准
- **约束和前提条件**：整理技术和时间约束
- **优先级排序**：分类Must-have/Nice-to-have

#### 阶段2: Design（设计）

- **架构设计**：系统组成和技术选择
- **数据设计**：模式、API规范、数据流
- **UI/UX设计**：屏幕组成和操作流程
- **风险分析**：潜在问题和对策

#### 阶段3: Implementation（实施）

- **任务分解**：细化为可实施的单位
- **进度跟踪**：通过TodoWrite进行状态管理
- **质量保证**：测试策略和验证方法
- **审批流程**：通过exit_plan_mode提交计划并等待明确审批

### 注意事项

**适用范围**

- Plan Mode最适合复杂的实施任务
- 简单修改或小规模变更时，使用常规实施形式
- 推荐用于3步以上的工作或新功能开发

**技术约束**

- 不依赖`exit_plan_mode`工具的返回值
- 审批流程通过用户明确的意思表示判断
- 与CLI的plan mode功能不同

**执行注意事项**

- 严禁未经审批开始实施
- 提交计划后务必等待用户响应
- 出错时提供替代方案

### 执行示例

```bash
# 使用示例
「制定用户管理系统的实施计划」

# 预期行为
# 1. 自动启动Plan Mode
# 2. 需求分析和技术选择
# 3. 结构化实施步骤
# 4. 通过exit_plan_mode提交计划
# 5. 审批后开始实施
```